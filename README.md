{
  "code": "from fastapi import FastAPI, HTTPException, Request, status\nfrom fastapi.responses import JSONResponse\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List\nimport re\nfrom threading import Lock\n\napp = FastAPI()\n\n# Regex for ISBN format: three digits, dash, ten digits\nISBN_REGEX = re.compile(r\"^\\d{3}-\\d{10}$\")\n\n# Lock for thread-safe operations on in-memory store\nlock = Lock()\n\nclass BookBase(BaseModel):\n    title: str = Field(..., min_length=1, max_length=255)\n    author: str = Field(..., min_length=1, max_length=255)\n    isbn: str\n    year: int\n\n    @validator('isbn')\n    def isbn_must_match_pattern(cls, v):\n        if not ISBN_REGEX.match(v):\n            raise ValueError('ISBN must be in format XXX-XXXXXXXXXX where X is digit')\n        return v\n\n    @validator('year')\n    def year_must_be_valid(cls, v):\n        from datetime import datetime\n        current_year = datetime.now().year\n        if v <= 0 or v > current_year:\n            raise ValueError(f'Year must be > 0 and <= {current_year}')\n        return v\n\nclass BookCreate(BookBase):\n    pass\n\nclass BookUpdate(BookBase):\n    pass\n\nclass Book(BookBase):\n    id: int\n\n# In-memory data store\nbooks_db = {}\nnext_id = 1\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"detail\": exc.detail},\n    )\n\n@app.post(\"/books\", status_code=status.HTTP_201_CREATED, response_model=Book)\ndef create_book(book: BookCreate):\n    global next_id\n    with lock:\n        # Check for duplicate ISBN\n        if any(b.isbn == book.isbn for b in books_db.values()):\n            raise HTTPException(status_code=400, detail=\"ISBN must be unique\")\n        book_data = book.dict()\n        book_data['id'] = next_id\n        books_db[next_id] = Book(**book_data)\n        next_id += 1\n        return books_db[book_data['id']]\n\n@app.get(\"/books\", response_model=List[Book])\ndef get_books():\n    # Ignore pagination query params gracefully\n    return list(books_db.values())\n\n@app.get(\"/books/{book_id}\", response_model=Book)\ndef get_book(book_id: int):\n    book = books_db.get(book_id)\n    if not book:\n        raise HTTPException(status_code=404, detail=\"Book not found\")\n    return book\n\n@app.put(\"/books/{book_id}\", response_model=Book)\ndef update_book(book_id: int, book_update: BookUpdate):\n    with lock:\n        existing = books_db.get(book_id)\n        if not existing:\n            raise HTTPException(status_code=404, detail=\"Book not found\")\n        # Check if new ISBN duplicates another book's ISBN\n        for b_id, b in books_db.items():\n            if b_id != book_id and b.isbn == book_update.isbn:\n                raise HTTPException(status_code=400, detail=\"ISBN must be unique\")\n        updated_data = book_update.dict()\n        updated_data['id'] = book_id\n        books_db[book_id] = Book(**updated_data)\n        return books_db[book_id]\n\n@app.delete(\"/books/{book_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_book(book_id: int):\n    with lock:\n        if book_id not in books_db:\n            raise HTTPException(status_code=404, detail=\"Book not found\")\n        del books_db[book_id]\n    return\n",
  "tests": "",
  "documentation": "This FastAPI application implements a REST API for managing books with CRUD operations. It uses Pydantic models for input validation, including strict checks on ISBN format and year boundaries. The in-memory dictionary simulates a database with thread-safe access via a lock. Duplicate ISBNs are disallowed. The API gracefully ignores unknown query parameters and enforces full payloads on updates. Proper HTTP status codes and error messages are returned for all error cases.",
  "dependencies": ["fastapi", "pydantic", "uvicorn"]
}