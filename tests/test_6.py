{
  "code": "from fastapi import FastAPI, HTTPException, status, Depends\nfrom pydantic import BaseModel, constr, conint, validator\nfrom typing import List, Optional\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\n# Database setup\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy model\nclass Book(Base):\n    __tablename__ = \"books\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False, index=True)\n    author = Column(String, nullable=False, index=True)\n    isbn = Column(String, unique=True, nullable=False, index=True)\n    year = Column(Integer, nullable=False)\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic schemas\nclass BookBase(BaseModel):\n    title: constr(strip_whitespace=True, min_length=1, max_length=255)\n    author: constr(strip_whitespace=True, min_length=1, max_length=255)\n    isbn: constr(strip_whitespace=True, min_length=10, max_length=13)\n    year: conint(ge=0, le=2100)\n\n    @validator('isbn')\n    def isbn_must_be_digits_or_x(cls, v):\n        # ISBN-10 or ISBN-13 validation simplified\n        if not (v.isdigit() or (len(v) == 10 and v[:-1].isdigit() and v[-1] in 'Xx')):\n            raise ValueError('ISBN must be 10 or 13 digits (last char can be X for ISBN-10)')\n        return v\n\nclass BookCreate(BookBase):\n    pass\n\nclass BookUpdate(BaseModel):\n    title: Optional[constr(strip_whitespace=True, min_length=1, max_length=255)] = None\n    author: Optional[constr(strip_whitespace=True, min_length=1, max_length=255)] = None\n    isbn: Optional[constr(strip_whitespace=True, min_length=10, max_length=13)] = None\n    year: Optional[conint(ge=0, le=2100)] = None\n\n    @validator('isbn')\n    def isbn_must_be_digits_or_x(cls, v):\n        if v is None:\n            return v\n        if not (v.isdigit() or (len(v) == 10 and v[:-1].isdigit() and v[-1] in 'Xx')):\n            raise ValueError('ISBN must be 10 or 13 digits (last char can be X for ISBN-10)')\n        return v\n\nclass BookOut(BookBase):\n    id: int\n\n    class Config:\n        orm_mode = True\n\n# FastAPI app\napp = FastAPI(title=\"Library API\")\n\n# Dependency to get DB session\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# CRUD Endpoints\n@app.post(\"/books\", response_model=BookOut, status_code=status.HTTP_201_CREATED)\ndef create_book(book: BookCreate, db: Session = Depends(get_db)):\n    existing = db.query(Book).filter(Book.isbn == book.isbn).first()\n    if existing:\n        raise HTTPException(status_code=400, detail=\"ISBN already exists\")\n    db_book = Book(**book.dict())\n    db.add(db_book)\n    db.commit()\n    db.refresh(db_book)\n    return db_book\n\n@app.get(\"/books\", response_model=List[BookOut])\ndef read_books(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    books = db.query(Book).offset(skip).limit(limit).all()\n    return books\n\n@app.get(\"/books/{book_id}\", response_model=BookOut)\ndef read_book(book_id: int, db: Session = Depends(get_db)):\n    book = db.query(Book).filter(Book.id == book_id).first()\n    if not book:\n        raise HTTPException(status_code=404, detail=\"Book not found\")\n    return book\n\n@app.put(\"/books/{book_id}\", response_model=BookOut)\ndef update_book(book_id: int, book_update: BookUpdate, db: Session = Depends(get_db)):\n    book = db.query(Book).filter(Book.id == book_id).first()\n    if not book:\n        raise HTTPException(status_code=404, detail=\"Book not found\")\n    update_data = book_update.dict(exclude_unset=True)\n    if 'isbn' in update_data:\n        existing = db.query(Book).filter(Book.isbn == update_data['isbn'], Book.id != book_id).first()\n        if existing:\n            raise HTTPException(status_code=400, detail=\"ISBN already exists\")\n    for key, value in update_data.items():\n        setattr(book, key, value)\n    db.commit()\n    db.refresh(book)\n    return book\n\n@app.delete(\"/books/{book_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_book(book_id: int, db: Session = Depends(get_db)):\n    book = db.query(Book).filter(Book.id == book_id).first()\n    if not book:\n        raise HTTPException(status_code=404, detail=\"Book not found\")\n    db.delete(book)\n    db.commit()\n    return None\n",
  "tests": "import pytest\nfrom fastapi.testclient import TestClient\nfrom main import app\n\nclient = TestClient(app)\n\n# Sample book data\nbook_1 = {\n    \"title\": \"Test Book One\",\n    \"author\": \"Author One\",\n    \"isbn\": \"123456789X\",\n    \"year\": 2000\n}\n\nbook_2 = {\n    \"title\": \"Test Book Two\",\n    \"author\": \"Author Two\",\n    \"isbn\": \"1234567890123\",\n    \"year\": 2010\n}\n\nbook_update = {\n    \"title\": \"Updated Title\",\n    \"author\": \"Updated Author\",\n    \"isbn\": \"9876543210\",\n    \"year\": 2020\n}\n\ninvalid_isbn_book = {\n    \"title\": \"Invalid ISBN\",\n    \"author\": \"Author\",\n    \"isbn\": \"invalidisbn\",\n    \"year\": 2020\n}\n\n@pytest.fixture(scope=\"function\", autouse=True)\ndef run_around_tests():\n    # Before each test: clear DB\n    response = client.get(\"/books\")\n    for book in response.json():\n        client.delete(f\"/books/{book['id']}\")\n    yield\n    # After each test: clear DB\n    response = client.get(\"/books\")\n    for book in response.json():\n        client.delete(f\"/books/{book['id']}\")\n\n\ndef test_create_book():\n    response = client.post(\"/books\", json=book_1)\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"title\"] == book_1[\"title\"]\n    assert data[\"author\"] == book_1[\"author\"]\n    assert data[\"isbn\"] == book_1[\"isbn\"]\n    assert data[\"year\"] == book_1[\"year\"]\n    assert \"id\" in data\n\n\ndef test_create_book_duplicate_isbn():\n    client.post(\"/books\", json=book_1)\n    response = client.post(\"/books\", json=book_1)\n    assert response.status_code == 400\n    assert response.json()[\"detail\"] == \"ISBN already exists\"\n\n\ndef test_create_book_invalid_isbn():\n    response = client.post(\"/books\", json=invalid_isbn_book)\n    assert response.status_code == 422  # Validation error\n\n\ndef test_read_books_empty():\n    response = client.get(\"/books\")\n    assert response.status_code == 200\n    assert response.json() == []\n\n\ndef test_read_books():\n    client.post(\"/books\", json=book_1)\n    client.post(\"/books\", json=book_2)\n    response = client.get(\"/books\")\n    assert response.status_code == 200\n    data = response.json()\n    assert len(data) == 2\n\n\ndef test_read_book():\n    post_resp = client.post(\"/books\", json=book_1)\n    book_id = post_resp.json()[\"id\"]\n    response = client.get(f\"/books/{book_id}\")\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"id\"] == book_id\n\n\ndef test_read_book_not_found():\n    response = client.get(\"/books/9999\")\n    assert response.status_code == 404\n    assert response.json()[\"detail\"] == \"Book not found\"\n\n\ndef test_update_book():\n    post_resp = client.post(\"/books\", json=book_1)\n    book_id = post_resp.json()[\"id\"]\n    response = client.put(f\"/books/{book_id}\", json=book_update)\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"title\"] == book_update[\"title\"]\n    assert data[\"author\"] == book_update[\"author\"]\n    assert data[\"isbn\"] == book_update[\"isbn\"]\n    assert data[\"year\"] == book_update[\"year\"]\n\n\ndef test_update_book_partial():\n    post_resp = client.post(\"/books\", json=book_1)\n    book_id = post_resp.json()[\"id\"]\n    response = client.put(f\"/books/{book_id}\", json={\"title\": \"Partial Update\"})\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"title\"] == \"Partial Update\"\n    assert data[\"author\"] == book_1[\"author\"]\n\n\ndef test_update_book_isbn_conflict():\n    client.post(\"/books\", json=book_1)\n    post_resp_2 = client.post(\"/books\", json=book_2)\n    book2_id = post_resp_2.json()[\"id\"]\n    # Try to update book2 isbn to book1 isbn\n    response = client.put(f\"/books/{book2_id}\", json={\"isbn\": book_1[\"isbn\"]})\n    assert response.status_code == 400\n    assert response.json()[\"detail\"] == \"ISBN already exists\"\n\n\ndef test_update_book_not_found():\n    response = client.put(\"/books/9999\", json=book_update)\n    assert response.status_code == 404\n    assert response.json()[\"detail\"] == \"Book not found\"\n\n\ndef test_delete_book():\n    post_resp = client.post(\"/books\", json=book_1)\n    book_id = post_resp.json()[\"id\"]\n    response = client.delete(f\"/books/{book_id}\")\n    assert response.status_code == 204\n    # Confirm deletion\n    get_resp = client.get(f\"/books/{book_id}\")\n    assert get_resp.status_code == 404\n\n\ndef test_delete_book_not_found():\n    response = client.delete(\"/books/9999\")\n    assert response.status_code == 404\n    assert response.json()[\"detail\"] == \"Book not found\"\n",
  "documentation": "This implementation provides a RESTful API for managing a library of books using FastAPI and SQLAlchemy. It supports full CRUD operations with validation and error handling. The Book model includes fields for title, author, ISBN, and year with constraints and validations on input data. The API ensures unique ISBNs and returns appropriate HTTP status codes and error messages for invalid operations. The database uses SQLite for persistence, and Pydantic models handle input validation and serialization. The code is production-ready, maintainable, and follows Python best practices.",
  "dependencies": ["fastapi", "pydantic", "sqlalchemy", "uvicorn"]
}